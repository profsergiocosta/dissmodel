{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DisSModel","text":"<p>Biblioteca para modelagem baseada em agentes e aut\u00f4matos celulares com suporte espacial.</p>"},{"location":"#visao-geral-da-ferramenta","title":"Vis\u00e3o Geral da Ferramenta","text":"<p>A ferramenta que aqui se apresenta foi concebida para a constru\u00e7\u00e3o e an\u00e1lise de modelos discretos, com \u00eanfase na simula\u00e7\u00e3o de sistemas din\u00e2micos espaciais. Inspirada na biblioteca Terrame, a proposta \u00e9 proporcionar um ambiente flex\u00edvel e integrado ao ecossistema Python, utilizando um conjunto de bibliotecas amplamente reconhecidas no mercado para facilitar tanto a modelagem quanto a visualiza\u00e7\u00e3o de dados espaciais.</p> <p>Embora a Terrame seja focada na simula\u00e7\u00e3o discreta e no controle de eventos discretos no dom\u00ednio territorial, a vers\u00e3o Python prop\u00f5e uma s\u00e9rie de m\u00f3dulos especializados para integrar funcionalidades geoespaciais, controle de eventos e visualiza\u00e7\u00e3o de maneira mais modular e extens\u00edvel.</p>"},{"location":"#objetivos","title":"Objetivos","text":"<ul> <li>Modelagem Discreta: A ferramenta permite a cria\u00e7\u00e3o de modelos discretos, utilizando a biblioteca Salabim para controle de eventos discretos.</li> <li>Integra\u00e7\u00e3o Espacial: Oferece uma camada robusta de suporte \u00e0 an\u00e1lise espacial por meio do uso de bibliotecas como GeoPandas, PySAL, Shapely e RasterStats, que permitem o tratamento e an\u00e1lise de dados geoespaciais.</li> <li>Visualiza\u00e7\u00e3o Interativa: Com o aux\u00edlio de Matplotlib e Streamlit, proporciona visualiza\u00e7\u00f5es ricas e interativas dos modelos gerados, auxiliando na an\u00e1lise e na interpreta\u00e7\u00e3o dos dados de maneira intuitiva.</li> <li>Publica\u00e7\u00e3o e Integra\u00e7\u00e3o: Inclui uma integra\u00e7\u00e3o com o DataWorld, permitindo que os modelos e resultados possam ser facilmente compartilhados, documentados e publicados.</li> </ul> <p>Esta ferramenta foi criada com o intuito de oferecer aos pesquisadores, analistas e engenheiros uma plataforma eficiente e adapt\u00e1vel para realizar experimentos e gerar resultados significativos em modelos discretos e an\u00e1lises espaciais.</p>"},{"location":"#estrutura-da-documentacao","title":"Estrutura da Documenta\u00e7\u00e3o","text":"<p>A documenta\u00e7\u00e3o est\u00e1 estruturada em quatro m\u00f3dulos principais, cada um com seu foco espec\u00edfico. A seguir, apresentamos os principais m\u00f3dulos que comp\u00f5em a ferramenta:</p> <ol> <li>M\u00f3dulo Core (Salabim): O m\u00f3dulo central da ferramenta, respons\u00e1vel pelo controle de eventos discretos e pela simula\u00e7\u00e3o do comportamento do modelo. Este m\u00f3dulo utiliza a biblioteca Salabim, que oferece funcionalidades robustas para a modelagem de processos discretos e controle de eventos no tempo.</li> <li>M\u00f3dulo Geo (GeoPandas, PySAL, Shapely, RasterStats): Este m\u00f3dulo oferece a infraestrutura necess\u00e1ria para trabalhar com dados geoespaciais. Com o uso de GeoPandas, \u00e9 poss\u00edvel carregar, manipular e analisar dados geogr\u00e1ficos em diversos formatos. Al\u00e9m disso, PySAL e Shapely permitem a an\u00e1lise espacial e a gera\u00e7\u00e3o de vizinhan\u00e7as, enquanto RasterStats possibilita a an\u00e1lise de dados rasterizados.</li> <li>M\u00f3dulo Visualization (Matplotlib, Streamlit): O m\u00f3dulo de visualiza\u00e7\u00e3o \u00e9 projetado para criar gr\u00e1ficos e interfaces interativas. Usando Matplotlib, \u00e9 poss\u00edvel gerar gr\u00e1ficos est\u00e1ticos detalhados, enquanto Streamlit facilita a cria\u00e7\u00e3o de interfaces interativas, permitindo ao usu\u00e1rio visualizar e manipular os resultados de maneira din\u00e2mica e em tempo real.</li> <li>M\u00f3dulo Publish (DataWorld): O m\u00f3dulo de publica\u00e7\u00e3o integra a ferramenta ao DataWorld, um ambiente colaborativo para visualiza\u00e7\u00e3o e compartilhamento de dados. Esta funcionalidade facilita a publica\u00e7\u00e3o de resultados, permitindo que o modelo e seus dados possam ser compartilhados e acessados por outros usu\u00e1rios de forma simples e eficiente.</li> </ol> <p></p>"},{"location":"examples/CA/","title":"Aut\u00f4matos Celulares no DisSModel","text":"<p>Aut\u00f4matos celulares s\u00e3o modelos baseados em grades espaciais discretas, onde cada c\u00e9lula evolui segundo regras locais que dependem do estado da pr\u00f3pria c\u00e9lula e de suas vizinhas.</p> <p>No contexto do DisSModel, utilizamos aut\u00f4matos celulares para simular processos como:</p> <ul> <li>Din\u00e2mica de popula\u00e7\u00f5es (ex. Game of Life)</li> <li>Propaga\u00e7\u00e3o de dist\u00farbios (ex. queimadas)</li> <li>Mudan\u00e7as em coberturas do solo</li> </ul> <p>A estrutura geral de um aut\u00f4mato celular no DisSModel inclui:</p> <ul> <li>Um ambiente espacial regular (grid)</li> <li>Um atributo de estado por c\u00e9lula</li> <li>Uma vizinhan\u00e7a (Rook, Queen, ou KNN via PySAL)</li> <li>Uma regra de atualiza\u00e7\u00e3o (<code>rule</code>)</li> <li>Um ciclo de execu\u00e7\u00e3o (<code>execute</code>)</li> </ul>"},{"location":"examples/CA/#estrategias-de-vizinhanca","title":"Estrat\u00e9gias de vizinhan\u00e7a","text":"<p>O DisSModel suporta diversas estrat\u00e9gias de vizinhan\u00e7a:</p> <ul> <li>Rook: considera c\u00e9lulas vizinhas nas dire\u00e7\u00f5es ortogonais (N, S, L, O)</li> <li>Queen: considera tamb\u00e9m as diagonais (N, NE, L, SE, S, SO, O, NO)</li> <li>KNN: vizinhos com base na proximidade (via <code>libpysal.weights.KNN</code>)</li> </ul> <p>Voc\u00ea pode usar qualquer uma dessas abordagens com o objeto <code>Neighborhood</code>, por exemplo:</p> <p>```python from libpysal.weights import KNN neigh = Neighborhood(KNN, gdf, use_index=True, k=4)</p>"},{"location":"examples/CA/fire_model/","title":"Modelo de Queimada","text":""},{"location":"examples/CA/fire_model/#exemplo-2-modelo-de-queimada-firemodelprob","title":"\ud83d\udd25 Exemplo 2: Modelo de Queimada (FireModelProb)","text":"<p>Este modelo simula a propaga\u00e7\u00e3o de fogo em uma floresta com regras probabil\u00edsticas:</p> <ul> <li>Uma c\u00e9lula em estado floresta pode:<ul> <li>Queimar se um vizinho estiver queimando.</li> <li>Pegar fogo com uma pequena chance aleat\u00f3ria (combust\u00e3o espont\u00e2nea).</li> </ul> </li> <li>Uma c\u00e9lula queimando vira queimada.</li> <li>Uma c\u00e9lula queimada pode voltar a ser floresta com chance de regenera\u00e7\u00e3o.</li> </ul>"},{"location":"examples/CA/fire_model/#estados","title":"Estados","text":"<pre><code>FOREST = 0      # Verde\nBURNING = 1     # Vermelho\nBURNED = 2      # Marrom\n</code></pre>"},{"location":"examples/CA/fire_model/#regra-de-transicao","title":"Regra de transi\u00e7\u00e3o","text":"<pre><code>def rule(self, idx):\n    state = self.gdf.loc[idx].state\n    if state == FOREST:\n        neighs = self.neighborhood.neighs(idx)\n        if (neighs.state == BURNING).any():\n            return BURNING\n        return BURNING if random.random() &lt; self.prob_combustion else FOREST\n    elif state == BURNING:\n        return BURNED\n    else:\n        return FOREST if random.random() &lt; self.prob_regrowth else BURNED\n</code></pre>"},{"location":"examples/CA/fire_model/#variacao-estrategias-de-vizinhanca","title":"Varia\u00e7\u00e3o: Estrat\u00e9gias de Vizinhan\u00e7a","text":"<p>Voc\u00ea pode trocar o tipo de vizinhan\u00e7a com um \u00fanico par\u00e2metro:</p> <pre><code>self.neighborhood = Neighborhood(Rook, gdf, use_index=True)\n</code></pre> <p>Ou usar KNN (K-Nearest Neighbors):</p> <pre><code>from libpysal.weights import KNN\nneigh = Neighborhood(KNN, gdf, k=4, use_index=True)\n</code></pre>"},{"location":"examples/CA/fire_model/#exemplo-de-execucao","title":"\ud83d\udcf7 Exemplo de execu\u00e7\u00e3o","text":""},{"location":"examples/CA/fire_model/#codigo-completo-firemodelprob","title":"\ud83d\udcbb C\u00f3digo completo (FireModelProb)","text":"<pre><code>from dissmodel.core import Model, Environment\nfrom dissmodel.geo.regular_grid import regular_grid\nfrom dissmodel.geo.fill import fill\nfrom dissmodel.visualization import Map\nfrom dissmodel.visualization.streamlit import display_inputs\nfrom matplotlib.colors import ListedColormap\nimport streamlit as st\nimport random\nfrom dissmodel.geo.neihborhood import Neighborhood\nfrom libpysal.weights.contiguity import Queen\n\nclass FireModelProb(Model):\n    FOREST = 0\n    BURNING = 1\n    BURNED = 2\n\n    def __init__(self, gdf, prob_combustion=0.001, prob_regrowth=0.1, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.prob_combustion = prob_combustion\n        self.prob_regrowth = prob_regrowth\n        self.gdf = gdf\n        self.neighborhood = Neighborhood(Queen, gdf, use_index=True)\n\n    def rule(self, idx):\n        state = self.gdf.loc[idx].state\n        if state == FireModelProb.FOREST:\n            neighs = self.neighborhood.neighs(idx)\n            if (neighs.state == FireModelProb.BURNING).any():\n                return FireModelProb.BURNING\n            else:\n                return FireModelProb.BURNING if random.random() &lt;= self.prob_combustion else FireModelProb.FOREST\n        elif state == FireModelProb.BURNING:\n            return FireModelProb.BURNED\n        else:\n            return FireModelProb.FOREST if random.random() &lt;= self.prob_regrowth else FireModelProb.BURNED\n\n    def execute(self):\n        self.gdf[\"state\"] = self.gdf.index.map(self.rule)\n\nst.set_page_config(page_title=\"Fire Model\", layout=\"centered\")\nst.title(\"Fire Model (DisSModel)\")\n\nst.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\ngrid_dim = st.sidebar.slider(\"Tamanho da grade\", min_value=5, max_value=100, value=20)\nexecutar = st.button(\"Executar Simula\u00e7\u00e3o\")\n\ngdf = regular_grid(dimension=(grid_dim, grid_dim), resolution=1, attrs={'state': 0})\nenv = Environment(end_time=steps, start_time=0)\nfire = FireModelProb(gdf=gdf)\ndisplay_inputs(fire, st.sidebar)\n\nplot_area = st.empty()\ncustom_cmap = ListedColormap(['green', 'red', 'brown'])\nplot_params = {\"column\": \"state\", \"cmap\": custom_cmap, \"ec\": \"black\"}\n\nMap(gdf=gdf, plot_area=plot_area, plot_params=plot_params)\n\nif executar:\n    env.run()\n</code></pre>"},{"location":"examples/CA/game_of_life/","title":"Game of Life","text":""},{"location":"examples/CA/game_of_life/#exemplo-1-game-of-life-jogo-da-vida","title":"\ud83d\udd32 Exemplo 1: Game of Life (Jogo da Vida)","text":"<p>O Game of Life, criado por John Conway, \u00e9 um aut\u00f4mato celular cl\u00e1ssico com regras simples:</p> <ul> <li>Uma c\u00e9lula viva permanece viva com 2 ou 3 vizinhos vivos.</li> <li>Uma c\u00e9lula morta revive com exatamente 3 vizinhos vivos.</li> </ul>"},{"location":"examples/CA/game_of_life/#componentes-do-modelo","title":"\ud83e\udde9 Componentes do Modelo","text":"<ul> <li>A grade \u00e9 inicializada com padr\u00f5es (ex: <code>glider</code>, <code>toad</code>, etc.), usando <code>fill(..., strategy=FillStrategy.PATTERN)</code>.</li> <li>A vizinhan\u00e7a usada \u00e9 a Queen, que considera os 8 vizinhos ao redor.</li> <li>A regra de atualiza\u00e7\u00e3o verifica o n\u00famero de vizinhos vivos para decidir o pr\u00f3ximo estado.</li> </ul> <pre><code>class GameOfLife(Model):\n    def rule(self, idx):\n        value = self.gdf.loc[idx].state\n        count = self.neighborhood.neighs(idx)[\"state\"].fillna(0).sum()\n        if value == 1:\n            return 1 if count in [2, 3] else 0\n        else:\n            return 1 if count == 3 else 0\n</code></pre>"},{"location":"examples/CA/game_of_life/#visualizacao","title":"\ud83d\uddbc\ufe0f Visualiza\u00e7\u00e3o","text":"<p>A visualiza\u00e7\u00e3o utiliza <code>Map(...)</code> com colormap personalizado:</p> <ul> <li>C\u00e9lulas vivas em vermelho (<code>state = 1</code>)</li> <li>C\u00e9lulas mortas em verde (<code>state = 0</code>)</li> <li>Interface interativa com <code>Streamlit</code> para ajustar tamanho da grade e passos da simula\u00e7\u00e3o.</li> </ul>"},{"location":"examples/CA/game_of_life/#exemplo-de-execucao","title":"\ud83d\udcf7 Exemplo de execu\u00e7\u00e3o","text":""},{"location":"examples/CA/game_of_life/#codigo-completo-game-of-life","title":"\ud83d\udcbb C\u00f3digo completo (Game of Life)","text":"<pre><code>from dissmodel.core import Model, Environment\nfrom dissmodel.geo import regular_grid, fill, FillStrategy, Neighborhood\nfrom dissmodel.visualization.map import Map\nfrom matplotlib.colors import ListedColormap\nimport streamlit as st\nimport random\nfrom libpysal.weights.contiguity import Queen\n\nclass GameOfLife(Model):\n    patterns = {\n        \"glider\": [\n            [0, 1, 0],\n            [0, 0, 1],\n            [1, 1, 1]\n        ],\n        \"toad\": [\n            [0, 1, 1, 1],\n            [1, 1, 1, 0]\n        ],\n        \"blinker\": [\n            [1, 1, 1]\n        ]\n    }\n\n    def setup(self, gdf):\n        self.gdf = gdf\n        self.neighborhood = Neighborhood(Queen, gdf, use_index=True)   \n\n    def rule(self, idx):\n        value = self.gdf.loc[idx].state\n        neighs = self.neighborhood.neighs(idx)\n        count = neighs[\"state\"].fillna(0).sum()\n        if value == 1:\n            return 1 if count in [2, 3] else 0\n        else:\n            return 1 if count == 3 else 0\n\n    def execute(self):\n        self.gdf[\"state\"] = self.gdf.index.map(self.rule)\n        print(self.env.now())\n\nst.set_page_config(page_title=\"Modelo Game of Life\", layout=\"centered\")\nst.title(\"Simula\u00e7\u00e3o com Game of Life (DisSModel)\")\n\nst.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\ngrid_dim = st.sidebar.slider(\"Tamanho da grade\", min_value=5, max_value=50, value=20)\n\ncustom_cmap = ListedColormap(['green', 'red'])\nplot_params = { \"column\": \"state\", \"cmap\": custom_cmap, \"ec\": 'black' }\n\ngrid = regular_grid(dimension=(grid_dim, grid_dim), resolution=1, attrs={'state': 0})\n\nfor name, pattern in GameOfLife.patterns.items():\n    start_x = random.randint(0, grid_dim - 5)\n    start_y = random.randint(0, grid_dim - 5)\n    fill(strategy=FillStrategy.PATTERN, gdf=grid, attr=\"state\", pattern=pattern, start_x=start_x, start_y=start_y)\n\nenv = Environment(end_time=steps, start_time=0)\nGameOfLife(gdf=grid)\n\nif st.button(\"Executar Simula\u00e7\u00e3o\"):\n    plot_area = st.empty()\n    Map(gdf=grid, plot_area=plot_area, plot_params=plot_params)\n    env.run()\n</code></pre>"},{"location":"modules/core/","title":"Core","text":""},{"location":"modules/core/#overview","title":"Overview","text":"<p>O M\u00f3dulo Core se baseia na poderosa biblioteca Salabim, que permite a constru\u00e7\u00e3o de simula\u00e7\u00f5es discretas e o controle de eventos no tempo. O m\u00f3dulo \u00e9 composto por duas classes principais: Environment e Model. Ambas s\u00e3o extens\u00f5es das classes fornecidas pelo Salabim, mas com melhorias que oferecem um controle mais preciso sobre o tempo de simula\u00e7\u00e3o, al\u00e9m de permitir a coleta de dados para visualiza\u00e7\u00e3o durante a execu\u00e7\u00e3o do modelo.</p>"},{"location":"modules/core/#classe-environment","title":"Classe <code>Environment</code>","text":"<p>A classe Environment \u00e9 uma extens\u00e3o da classe <code>sim.Environment</code> do Salabim, que foi customizada para permitir a defini\u00e7\u00e3o de um tempo inicial e tempo final de simula\u00e7\u00e3o, oferecendo maior flexibilidade no controle da execu\u00e7\u00e3o.</p>"},{"location":"modules/core/#funcionalidades","title":"Funcionalidades","text":"<ul> <li>Tempo Inicial e Final Personalizados: A classe permite a defini\u00e7\u00e3o de um <code>start_time</code> e <code>end_time</code> personalizados para a simula\u00e7\u00e3o, proporcionando um controle mais preciso sobre os per\u00edodos em que a simula\u00e7\u00e3o deve ocorrer.</li> <li>Execu\u00e7\u00e3o da Simula\u00e7\u00e3o: O m\u00e9todo <code>run</code> da classe \u00e9 respons\u00e1vel por rodar a simula\u00e7\u00e3o, respeitando os tempos de in\u00edcio e fim definidos. Se um tempo <code>till</code> for fornecido, ele substituir\u00e1 o <code>end_time</code>, permitindo maior flexibilidade durante a execu\u00e7\u00e3o.</li> <li>Reset de Estat\u00edsticas: O m\u00e9todo <code>reset</code> \u00e9 respons\u00e1vel por limpar os dados de visualiza\u00e7\u00e3o, caso existam, e reiniciar os componentes de estat\u00edsticas ou gr\u00e1ficos. Isso \u00e9 \u00fatil quando se deseja reiniciar uma simula\u00e7\u00e3o com dados limpos.</li> </ul>"},{"location":"modules/core/#classe-model","title":"Classe <code>Model</code>","text":"<p>A classe Model \u00e9 uma extens\u00e3o da classe <code>sim.Component</code> do Salabim, com melhorias no controle de tempo de execu\u00e7\u00e3o e no armazenamento de dados para visualiza\u00e7\u00f5es gr\u00e1ficas.</p>"},{"location":"modules/core/#funcionalidades_1","title":"Funcionalidades","text":"<ul> <li>Controle de Tempo Personalizado: Assim como na classe <code>Environment</code>, a classe Model permite que a simula\u00e7\u00e3o seja controlada por tempo de in\u00edcio e tempo de t\u00e9rmino definidos pelo usu\u00e1rio.</li> <li>Execu\u00e7\u00e3o do Processo: O m\u00e9todo <code>process</code> controla o ciclo de vida do modelo, aguardando at\u00e9 o tempo de in\u00edcio e realizando a execu\u00e7\u00e3o at\u00e9 o tempo de t\u00e9rmino. O processo pode ser dividido em etapas (passos), com o tempo de espera entre essas etapas configurado pelo usu\u00e1rio.</li> <li>Armazenamento de Dados para Visualiza\u00e7\u00e3o: Ao definir atributos que devem ser plotados, a classe garante que esses dados sejam coletados e armazenados em um dicion\u00e1rio de metadados. Essa funcionalidade facilita a cria\u00e7\u00e3o de gr\u00e1ficos durante a execu\u00e7\u00e3o do modelo.</li> </ul>"},{"location":"modules/core/#como-utilizar","title":"Como Utilizar","text":"<ul> <li> <p>Instancia\u00e7\u00e3o do Ambiente: O usu\u00e1rio pode criar uma inst\u00e2ncia do ambiente com um tempo de in\u00edcio e fim definidos.</p> <pre><code>env = Environment(start_time=10, end_time=50)\n</code></pre> </li> <li> <p>Cria\u00e7\u00e3o de Modelos: Os modelos podem ser instanciados com tempos de in\u00edcio e fim espec\u00edficos, al\u00e9m de definir o intervalo entre os passos.</p> <pre><code>model = Model(start_time=10, end_time=40, step=2, name=\"Modelo de Transporte\")\nmodel.process()\n</code></pre> </li> <li> <p>Execu\u00e7\u00e3o da Simula\u00e7\u00e3o: Para rodar a simula\u00e7\u00e3o com os tempos definidos, o m\u00e9todo <code>run</code> do ambiente deve ser chamado.</p> <pre><code>env.run()\n</code></pre> </li> </ul> <p>Essas duas classes proporcionam um controle mais fino sobre os tempos de execu\u00e7\u00e3o e permitem coletar dados automaticamente para visualiza\u00e7\u00e3o, o que facilita a an\u00e1lise dos resultados. Elas s\u00e3o fundamentais para construir modelos discretos mais din\u00e2micos e personalizados.</p>"},{"location":"modules/core/#exemplo","title":"Exemplo","text":"<p>O controle de tempo no M\u00f3dulo Core \u00e9 um dos aspectos mais poderosos da ferramenta. A seguir, apresentamos um exemplo pr\u00e1tico que demonstra como diferentes modelos podem ser executados em um ambiente de simula\u00e7\u00e3o com tempos de in\u00edcio e fim espec\u00edficos, permitindo a execu\u00e7\u00e3o paralela ou sequencial.</p> <p>Vamos ilustrar como tr\u00eas modelos (<code>ModeloA</code>, <code>ModeloB</code> e <code>ModeloC</code>) podem ser configurados para executar em diferentes intervalos de tempo dentro de um ambiente de simula\u00e7\u00e3o. O exemplo abaixo utiliza as classes Environment e Model do m\u00f3dulo Core.</p> <pre><code>from dissmodel.core import Model, Environment\n\nclass ModeloA(Model):\n    def execute(self):\n        print(f\"[A] Tempo: {self.env.now()}\")\n\nclass ModeloB(Model):\n    def execute(self):\n        print(f\"[B] Tempo: {self.env.now()}\")\n\nclass ModeloC(Model):\n    def execute(self):\n        print(f\"[C] Tempo: {self.env.now()}\")\n\n# Cria o ambiente com tempo inicial e final definidos\nenv_a = Environment(name=\"Modelo A\",\n                    start_time = 2010, end_time=2016)\n\n# Instancia os modelos com tempos de in\u00edcio e fim diferentes\nModeloA(start_time=2012)\nModeloB(end_time=2013)\nModeloC()\n\n# Roda a simula\u00e7\u00e3o\nenv_a.run()\n</code></pre> <p>Sa\u00edda Esperada</p> <pre><code>Running from 2010 to 2016 (duration: 6)\n[B] Tempo: 2010.0\n[C] Tempo: 2010.0\n[B] Tempo: 2011.0\n[C] Tempo: 2011.0\n[A] Tempo: 2012.0\n[B] Tempo: 2012.0\n[C] Tempo: 2012.0\n[A] Tempo: 2013.0\n[C] Tempo: 2013.0\n[A] Tempo: 2014.0\n[C] Tempo: 2014.0\n[A] Tempo: 2015.0\n[C] Tempo: 2015.0\n[A] Tempo: 2016.0\n[C] Tempo: 2016.0\n</code></pre>"},{"location":"modules/core/#interpretacao-dos-resultados","title":"Interpreta\u00e7\u00e3o dos Resultados","text":"<p>Neste exemplo, instanciamos um ambiente de simula\u00e7\u00e3o com intervalo temporal entre 2010 e 2016. Tr\u00eas modelos distintos s\u00e3o inseridos nesse ambiente, cada um com sua configura\u00e7\u00e3o temporal espec\u00edfica:</p> <ul> <li><code>ModeloA</code>: executa a partir de 2012 at\u00e9 o final do ambiente (2016).</li> <li><code>ModeloB</code>: inicia em 2010 e termina em 2013.</li> <li><code>ModeloC</code>: executa continuamente durante todo o intervalo da simula\u00e7\u00e3o, de 2010 a 2016.</li> </ul> <p>A sa\u00edda mostra os registros temporais de execu\u00e7\u00e3o de cada modelo, evidenciando como o mecanismo de controle de tempo personalizado permite a execu\u00e7\u00e3o simult\u00e2nea e coordenada dos modelos, de acordo com seus respectivos intervalos de atua\u00e7\u00e3o.</p>"},{"location":"modules/core/#modelagem-orientada-a-objetos","title":"Modelagem Orientada a Objetos","text":"<p>A ferramenta \u00e9 estruturada com base nos princ\u00edpios de programa\u00e7\u00e3o orientada a objetos (POO), permitindo encapsular dados e comportamentos em classes reutiliz\u00e1veis, estendendo modelos e compondo sistemas complexos de forma modular.</p> <p>Cada modelo criado herda da classe base <code>Model</code>, que garante a integra\u00e7\u00e3o com o ambiente de simula\u00e7\u00e3o (<code>Environment</code>) e permite que m\u00e9todos como <code>setup()</code> e <code>execute()</code> sejam chamados automaticamente a cada passo da simula\u00e7\u00e3o.</p> <p>Exemplo: Modelo SIR</p> <pre><code>class SIR(Model):\n\n    def __init__(self, susceptible=9998, infected=2, recovered=0, duration=2,\n                 contacts=6, probability=0.25, final_time=30):\n        super().__init__()\n        self.susceptible = susceptible\n        self.infected = infected\n        self.recovered = recovered\n        self.duration = duration\n        self.contacts = contacts\n        self.probability = probability\n        self.final_time = final_time\n\n    def update(self):\n        total = self.susceptible + self.infected + self.recovered\n        alpha = self.contacts * self.probability\n        prop = self.susceptible / total\n        new_infected = self.infected * alpha * prop\n        new_recovered = self.infected / self.duration\n        self.susceptible -= new_infected\n        self.infected += new_infected - new_recovered\n        self.recovered += new_recovered\n\n    def execute(self):\n        self.update()\n</code></pre> <p>A estrutura orientada a objetos facilita a extens\u00e3o do modelo, a separa\u00e7\u00e3o de responsabilidades e a reutiliza\u00e7\u00e3o de l\u00f3gica entre diferentes simula\u00e7\u00f5es.</p> <p>\ud83e\uddea Classe do Modelo: SIR</p> <p>Define o modelo SIR como uma subclasse de Model.</p> <pre><code>class SIR(Model):\n</code></pre> <p>Esses s\u00e3o atributos do modelo: - susceptible: n\u00famero de pessoas suscet\u00edveis. - infected: n\u00famero de pessoas infectadas. - recovered: n\u00famero de pessoas recuperadas. - duration: tempo m\u00e9dio que uma pessoa permanece infectada.</p> <p>\ud83d\udd27 Construtor init</p> <p>Define valores padr\u00e3o para o modelo e armazena os par\u00e2metros:</p> <ul> <li>contacts: n\u00famero m\u00e9dio de contatos por infectado por unidade de tempo.</li> <li>probability: probabilidade de cont\u00e1gio por contato.</li> <li>final_time: tempo final da simula\u00e7\u00e3o.</li> </ul> <p>Os outros par\u00e2metros (susceptible, etc.) s\u00e3o os estados iniciais do modelo.</p> <p>Note que super().init() \u00e9 chamado para garantir que a l\u00f3gica de tempo e ambiente do DisSModel seja inicializada corretamente.</p> <p>\ud83d\udd01 M\u00e9todo update <pre><code>def update(self):\n</code></pre> Este m\u00e9todo atualiza os valores das vari\u00e1veis do modelo a cada passo de tempo. A l\u00f3gica segue as equa\u00e7\u00f5es diferenciais cl\u00e1ssicas do modelo SIR, adaptadas para forma discreta:</p> <p>C\u00e1lculos: Popula\u00e7\u00e3o total:</p> <p><pre><code>total = self.susceptible + self.infected + self.recovered\nTaxa de infec\u00e7\u00e3o:\n</code></pre> <pre><code>alpha = self.contacts * self.probability\nPropor\u00e7\u00e3o de suscet\u00edveis:\n</code></pre> <pre><code>prop = self.susceptible / total\nNovos infectados:\n</code></pre> <pre><code>new_infected = self.infected * alpha * prop\nNovos recuperados:\n</code></pre></p> <pre><code>new_recovered = self.infected / self.duration\n</code></pre> <p>Atualiza\u00e7\u00e3o dos estados: <pre><code>self.susceptible -= new_infected\nself.infected += new_infected - new_recovered\nself.recovered += new_recovered\n</code></pre></p> <p>\u25b6\ufe0f M\u00e9todo execute <pre><code>def execute(self):\n    self.update()\n</code></pre> Esse m\u00e9todo \u00e9 chamado a cada passo de tempo do ambiente do DisSModel. Aqui, ele apenas chama self.update() \u2014 ou seja, aplica a l\u00f3gica do modelo a cada instante.</p>"},{"location":"modules/geo/","title":"Geo","text":"<p>O m\u00f3dulo dissmodel.geo fornece utilit\u00e1rios para modelagem espacial, como:</p> <pre><code>from dissmodel.geo import Neighborhood, regular_grid, fill\n</code></pre> <p>Antes de destacar esses recurso, \u00e9 importante ressaltar que O cora\u00e7\u00e3o da integra\u00e7\u00e3o geogr\u00e1fica est\u00e1 no fato de que qualquer modelo pode operar diretamente sobre um <code>GeoDataFrame</code> do GeoPandas. Isso permite que se use dados espaciais reais (como shapefiles, arquivos GeoJSON, etc.) como entrada e sa\u00edda do modelo, facilitando an\u00e1lises espaciais visuais e quantitativas.</p>"},{"location":"modules/geo/#exemplo-simples-de-uso-de-dados-geograficos","title":"Exemplo Simples de uso de dados geogr\u00e1ficos","text":"<p>Come\u00e7ando pela  defini\u00e7\u00e3o do Modelo</p> <pre><code>@track_plot(\"media_altitude\", \"blue\")\nclass ElevacaoSimples(Model):\n    seaLevelRiseRate: float\n    media_altitude: float\n\n    def setup(self, gdf, seaLevelRiseRate=0.01):\n        self.gdf = gdf\n        self.seaLevelRiseRate = seaLevelRiseRate\n        self.media_altitude = 0\n\n    def execute(self):\n        self.gdf[\"Alt2\"] += self.seaLevelRiseRate\n        self.media_altitude = self.gdf[\"Alt2\"].mean()\n</code></pre> <ul> <li><code>gdf</code>: o <code>GeoDataFrame</code> com a geometria e atributos espaciais.</li> <li>A cada passo de tempo, a eleva\u00e7\u00e3o (<code>Alt2</code>) \u00e9 incrementada de forma uniforme.</li> <li>A m\u00e9dia da eleva\u00e7\u00e3o \u00e9 calculada para acompanhamento em gr\u00e1fico.</li> </ul> <p>Leitura dos Dados Geogr\u00e1ficos</p> <pre><code>gdf = gpd.read_file(\"filename.shp\")\n</code></pre> <p>O shapefile \u00e9 carregado como um <code>GeoDataFrame</code>, que armazena:</p> <ul> <li>Informa\u00e7\u00f5es espaciais (coluna <code>geometry</code>);</li> <li>Atributos como <code>\"Alt2\"</code> (eleva\u00e7\u00e3o), <code>\"Usos\"</code>, etc.</li> </ul> <p>Instancia\u00e7\u00e3o do Modelo e Ambiente</p> <pre><code>env = Environment(start_time=1, end_time=20)\nmodelo = ElevacaoSimples(gdf=gdf, seaLevelRiseRate=0.01)\n</code></pre> <ul> <li>O <code>Environment</code> controla o tempo e executa todos os modelos registrados.</li> <li>O modelo recebe o <code>GeoDataFrame</code> como par\u00e2metro \u2014 isso j\u00e1 o conecta \u00e0 estrutura espacial dos dados.</li> </ul> <p>Visualiza\u00e7\u00e3o Espacial e Temporal</p> <ul> <li>Mapa</li> </ul> <pre><code>Map(gdf=gdf, plot_params={\n    \"column\": \"Alt2\", \"scheme\": \"quantiles\", \"k\": 5,\n    \"legend\": True, \"cmap\": \"Blues\"\n})\n</code></pre> <ul> <li>O mapa mostra a coluna <code>Alt2</code> (eleva\u00e7\u00e3o), atualizada a cada passo da simula\u00e7\u00e3o.</li> <li> <p>A visualiza\u00e7\u00e3o pode ser local (matplotlib) ou em apps interativos (como Streamlit).</p> </li> <li> <p>Gr\u00e1fico</p> </li> </ul> <pre><code>Chart(select={\"media_altitude\"})\n</code></pre> <ul> <li>A curva da m\u00e9dia de eleva\u00e7\u00e3o \u00e9 exibida dinamicamente ao longo do tempo.</li> <li>O decorador <code>@track_plot</code> automatiza isso sem c\u00f3digo adicional.</li> </ul> <p>Execu\u00e7\u00e3o da Simula\u00e7\u00e3o</p> <pre><code>env.run()\n</code></pre> <p>Com esse comando, o ambiente:</p> <ul> <li>Avan\u00e7a no tempo de <code>start_time</code> at\u00e9 <code>end_time</code>;</li> <li>Chama <code>execute()</code> do modelo a cada passo;</li> <li>Atualiza mapas e gr\u00e1ficos automaticamente.</li> </ul> <p>Essa integra\u00e7\u00e3o mostra a for\u00e7a da orienta\u00e7\u00e3o a objetos no DisSModel: modelos simples podem operar diretamente sobre dados reais com c\u00f3digo m\u00ednimo. Isso torna poss\u00edvel:</p> <p>\u2705 Prototipar rapidamente cen\u00e1rios ambientais, urbanos, etc.</p> <p>\u2705 Visualizar dinamicamente mapas e s\u00e9ries temporais.</p> <p>\u2705 Ampliar o modelo com l\u00f3gica espacial (vizinhan\u00e7a, inunda\u00e7\u00e3o, etc.).</p>"},{"location":"modules/geo/#grade-regular-regular-grid","title":"Grade Regular (Regular Grid)","text":"<p>A fun\u00e7\u00e3o <code>regular_grid</code> cria um grade retangular de c\u00e9lulas (ou seja, pol\u00edgonos quadrados ou retangulares), retornando um <code>GeoDataFrame</code> contendo:</p> <ul> <li>A geometria de cada c\u00e9lula (<code>Polygon</code>);</li> <li>Um identificador \u00fanico (<code>id</code>);</li> <li>Atributos opcionais que podem ser usados na simula\u00e7\u00e3o;</li> <li>CRS opcional.</li> </ul> <p>Esse tipo de estrutura \u00e9 especialmente \u00fatil em modelos baseados em espa\u00e7o celular, comuns em ecologia, urbanismo, din\u00e2mica populacional, etc.</p> <p>Voc\u00ea pode gerar a grade de 3 formas principais:</p>"},{"location":"modules/geo/#1-a-partir-de-um-geodataframe","title":"1. A partir de um <code>GeoDataFrame</code>","text":"<pre><code>regular_grid(gdf=meu_gdf, resolution=100)\n</code></pre> <p>Gera uma grade que cobre completamente os limites espaciais de um GeoDataFrame, com c\u00e9lulas de 100x100 unidades no sistema de coordenadas usado.</p>"},{"location":"modules/geo/#2-a-partir-de-bounds-e-resolution","title":"2. A partir de <code>bounds</code> e <code>resolution</code>","text":"<pre><code>regular_grid(bounds=(0, 0, 1000, 1000), resolution=100)\n</code></pre> <p>Gera uma grade regular de 10x10 c\u00e9lulas de 100x100 metros, cobrindo uma \u00e1rea de 1km\u00b2.</p>"},{"location":"modules/geo/#3-a-partir-de-dimension-e-resolution-sem-localizacao-geografica","title":"3. A partir de <code>dimension</code> e <code>resolution</code> (sem localiza\u00e7\u00e3o geogr\u00e1fica)","text":"<pre><code>regular_grid(dimension=(5, 4), resolution=50)\n</code></pre> <p>Gera uma grade de 5 colunas e 4 linhas com c\u00e9lulas de 50x50 unidades, posicionada com canto inferior esquerdo em (0, 0). \u00datil para simula\u00e7\u00f5es puramente abstratas.</p>"},{"location":"modules/geo/#exemplos-de-uso","title":"\ud83e\uddea Exemplos de Uso","text":""},{"location":"modules/geo/#exemplo-1-grid-sobre-shapefile-real","title":"\u2705 Exemplo 1: Grid sobre shapefile real","text":"<pre><code>import geopandas as gpd\nfrom dissmodel.geo import regular_grid\n\ngdf_base = gpd.read_file(\"usos.shp\")\ngrid = regular_grid(gdf=gdf_base, resolution=50)\n\ngrid.plot(edgecolor=\"gray\", facecolor=\"none\")\n</code></pre> <p>Esse exemplo cria uma malha com c\u00e9lulas de 50 metros de lado sobre o shapefile de entrada. Pode ser usada para acoplar dados raster, simular ocupa\u00e7\u00f5es ou iniciar modelos baseados em vizinhan\u00e7a.</p>"},{"location":"modules/geo/#exemplo-2-grid-com-atributos-personalizados","title":"\u2705 Exemplo 2: Grid com atributos personalizados","text":"<pre><code>grid = regular_grid(bounds=(0, 0, 500, 500), resolution=100, attrs={\"elevacao\": 0.5, \"ocupado\": False})\nprint(grid.head())\n</code></pre> <p>Esse grid ter\u00e1 c\u00e9lulas de 100x100 cobrindo 500x500 unidades, cada uma com os atributos <code>\"elevacao\"</code> e <code>\"ocupado\"</code> inicializados.</p>"},{"location":"modules/geo/#exemplo-3-grid-abstrato-sem-localizacao-real","title":"\u2705 Exemplo 3: Grid abstrato (sem localiza\u00e7\u00e3o real)","text":"<pre><code>grid = regular_grid(dimension=(10, 10), resolution=1)\ngrid.plot()\n</code></pre> <p>Cria uma grade 10x10 sem refer\u00eancia espacial (inicia em (0, 0)), \u00fatil para testes ou modelos conceituais sem georreferenciamento.</p>"},{"location":"modules/geo/#uso-tipico","title":"Uso t\u00edpico","text":"<p>O grid gerado pode ser usado diretamente em modelos como este:</p> <pre><code>class ModeloAbstrato(Model):\n\n    def setup(self, gdf):\n        self.gdf = gdf\n\n    def execute(self):\n        # Simples exemplo: aumenta o valor de uma vari\u00e1vel fict\u00edcia\n        self.gdf[\"valor\"] += 1\n</code></pre> <p>Voc\u00ea pode acoplar dados externos ao grid, usar <code>dissmodel.geo.Neighborhood</code> para definir vizinhan\u00e7as, ou aplicar l\u00f3gicas espaciais em cima dele.</p> <p>A fun\u00e7\u00e3o <code>regular_grid</code> permite que voc\u00ea:</p> <ul> <li>Crie grades celulares alinhadas com o espa\u00e7o real;</li> <li>Construa modelos espaciais com ou sem georreferenciamento;</li> <li>Agregue atributos simulados ou observados por c\u00e9lula;</li> <li>Visualize ou exporte esses grids para an\u00e1lise geogr\u00e1fica.</li> </ul>"},{"location":"modules/geo/#fill-preenchimento-de-celulas","title":"Fill (preenchimento de c\u00e9lulas)","text":"<p>O m\u00f3dulo <code>fill</code> permite atribuir ou agregar dados espaciais de forma autom\u00e1tica a uma grade regular.</p> <p>Esse processo \u00e9 essencial para modelagem espacial, pois permite associar:</p> <ul> <li>\ud83d\udcca dados cont\u00ednuos (ex: altitude, NDVI, temperatura \u2014 via estat\u00edsticas zonais);</li> <li>\ud83d\udccd dados pontuais ou poligonais (ex: dist\u00e2ncia a rios, estradas \u2014 via dist\u00e2ncia m\u00ednima);</li> <li>\ud83c\udfb2 dados sint\u00e9ticos ou padr\u00f5es (ex: valores simulados \u2014 via amostragem aleat\u00f3ria ou padr\u00f5es predefinidos).</li> </ul> <p>\u2733\ufe0f Estrutura do M\u00f3dulo <code>fill</code></p> <ul> <li><code>fill(strategy=\"nome\", **kwargs)</code>: Interface principal.</li> <li><code>FillStrategy</code>: Enum com estrat\u00e9gias como <code>zonal_stats</code>, <code>min_distance</code>, <code>random_sample</code>, <code>pattern</code>.</li> </ul> <p>A seguir s\u00e3o apresentados alguns exemplos</p>"},{"location":"modules/geo/#1-preencher-a-grade-com-estatisticas-zonais-de-um-raster-ex-altitude-media-por-celula","title":"\u2705 1. Preencher a grade com estat\u00edsticas zonais de um raster (ex: altitude m\u00e9dia por c\u00e9lula)","text":"<pre><code>from dissmodel.geo import regular_grid, fill, FillStrategy\nimport rasterio\n\n# Cria a grade regular com base em shapefile de interesse\ngdf_base = gpd.read_file(\"area.shp\")\ngrade = regular_grid(gdf=gdf_base, resolution=50)\n\n# Abre o raster\nwith rasterio.open(\"altitude.tif\") as src:\n    raster = src.read(1)\n    affine = src.transform\n\n# Aplica estat\u00edsticas zonais\nfill(\n    strategy=FillStrategy.ZONAL_STATS,\n    vectors=grade,\n    raster_data=raster,\n    affine=affine,\n    stats=[\"mean\", \"min\", \"max\"],\n    prefix=\"alt_\"\n)\n\nprint(grade[[\"alt_mean\", \"alt_min\", \"alt_max\"]].head())\n</code></pre> <p>\ud83d\udd39 Uso t\u00edpico: preencher as c\u00e9lulas com a m\u00e9dia de eleva\u00e7\u00e3o, cobertura vegetal, umidade, etc.</p>"},{"location":"modules/geo/#2-atribuir-a-cada-celula-a-menor-distancia-ate-feicoes-de-interesse-ex-rios-ou-estradas","title":"\u2705 2. Atribuir a cada c\u00e9lula a menor dist\u00e2ncia at\u00e9 fei\u00e7\u00f5es de interesse (ex: rios ou estradas)","text":"<pre><code>rios = gpd.read_file(\"rios.shp\")\n\nfill(\n    strategy=FillStrategy.MIN_DISTANCE,\n    from_gdf=grade,\n    to_gdf=rios,\n    attr_name=\"dist_rio\"\n)\n\nprint(grade[[\"dist_rio\"]].head())\n</code></pre> <p>\ud83d\udd39 Uso t\u00edpico: simula\u00e7\u00f5es que dependem de acessibilidade, risco de inunda\u00e7\u00e3o, zonas de influ\u00eancia.</p>"},{"location":"modules/geo/#3-amostragem-aleatoria-de-valores-ex-estados-iniciais-de-ocupacao-altitude-sintetica","title":"\u2705 3. Amostragem aleat\u00f3ria de valores (ex: estados iniciais de ocupa\u00e7\u00e3o, altitude sint\u00e9tica)","text":"<pre><code>fill(\n    strategy=FillStrategy.RANDOM_SAMPLE,\n    gdf=grade,\n    attr=\"ocupacao\",\n    data={0: 0.7, 1: 0.3},  # 70% de c\u00e9lulas com 0, 30% com 1\n    seed=42\n)\n\ngrade[\"ocupacao\"].value_counts()\n</code></pre> <p>\ud83d\udd39 Uso t\u00edpico: inicializar modelos com padr\u00f5es aleat\u00f3rios realistas.</p>"},{"location":"modules/geo/#4-aplicar-um-padrao-fixo-em-grade-util-para-testes-ou-comportamentos-controlados","title":"\u2705 4. Aplicar um padr\u00e3o fixo em grade (\u00fatil para testes ou comportamentos controlados)","text":"<pre><code>pattern = [\n    [1, 0, 0],\n    [0, 1, 0],\n    [0, 0, 1]\n]\n\nfill(\n    strategy=FillStrategy.PATTERN,\n    gdf=grade,\n    attr=\"tipo\",\n    pattern=pattern,\n    start_x=0,\n    start_y=0\n)\n\ngrade[\"tipo\"].value_counts()\n</code></pre> <p>\ud83d\udd39 Uso t\u00edpico: teste de difus\u00e3o, padr\u00f5es iniciais em simula\u00e7\u00f5es de propaga\u00e7\u00e3o, checagem visual.</p> <p>A fun\u00e7\u00e3o <code>fill</code> e suas estrat\u00e9gias oferecem uma interface flex\u00edvel e extens\u00edvel para:</p> <ul> <li>Integrar dados vetoriais e raster a grades espaciais;</li> <li>Preparar dados de entrada para modelos baseados em c\u00e9lula;</li> <li>Realizar an\u00e1lises espaciais simples sem depender de ferramentas externas complexas.</li> </ul> <p>Voc\u00ea pode at\u00e9 registrar novas estrat\u00e9gias personalizadas usando:</p> <pre><code>@register_strategy(\"min_max_ratio\")\ndef fill_min_max_ratio(...):\n    ...\n</code></pre>"},{"location":"modules/geo/#neighborhood-vizinhanca","title":"Neighborhood (vizinhan\u00e7a)","text":"<ul> <li>Permite construir rela\u00e7\u00f5es de vizinhan\u00e7a via:<ul> <li><code>strategy</code> (ex: <code>Queen</code>, <code>Rook</code> \u2014 adjac\u00eancia com base em borda ou v\u00e9rtice)</li> <li>Um dicion\u00e1rio <code>neighbors_dict</code> com vizinhos precomputados (ou de um JSON salvo)</li> </ul> </li> <li>Exponibiliza:<ul> <li><code>.neighs(idx)</code>: retorna o subconjunto <code>GeoDataFrame</code> com os vizinhos da c\u00e9lula <code>idx</code></li> <li><code>.idxs(idx)</code>: retorna apenas os \u00edndices dos vizinhos</li> </ul> </li> </ul>"},{"location":"modules/geo/#exemplo-de-uso-construcao-de-vizinhanca","title":"\u2705 Exemplo de Uso \u2014 Constru\u00e7\u00e3o de vizinhan\u00e7a","text":"<pre><code>import geopandas as gpd\nfrom libpysal.weights import Queen\nfrom dissmodel.geo import Neighborhood\n\n# Carregar grade ou pol\u00edgonos\ngrade = gpd.read_file(\"grade_espacial.shp\")\n\n# Criar vizinhan\u00e7a do tipo Queen\nvizinhanca = Neighborhood(strategy=Queen, gdf=grade, ids=grade.index)\n\n# Ver vizinhos do elemento \"5-4\"\nvizinhos_54 = vizinhanca.neighs(\"5-4\")\nprint(vizinhos_54)\n\n# Apenas os \u00edndices\nprint(vizinhanca.idxs(\"5-4\"))\n</code></pre>"},{"location":"modules/geo/#exemplo-dentro-de-um-modelo-difusao-simples","title":"\ud83e\udde9 Exemplo dentro de um modelo: Difus\u00e3o simples","text":"<p>Simula\u00e7\u00e3o de difus\u00e3o onde cada c\u00e9lula adota o valor mais comum entre os vizinhos.</p> <pre><code>from dissmodel.core import Model\nfrom dissmodel.geo import Neighborhood\nfrom collections import Counter\n\nclass DifusaoVizinhos(Model):\n    def setup(self, gdf, attr=\"estado\"):\n        self.gdf = gdf\n        self.attr = attr\n        self.neigh = Neighborhood(strategy=Queen, gdf=gdf)\n\n    def execute(self):\n        novo_estado = {}\n\n        for idx in self.gdf.index:\n            vizinhos = self.neigh.idxs(idx)\n            estados = self.gdf.loc[vizinhos, self.attr].tolist()\n            if estados:\n                mais_comum = Counter(estados).most_common(1)[0][0]\n                novo_estado[idx] = mais_comum\n            else:\n                novo_estado[idx] = self.gdf.loc[idx, self.attr]\n\n        self.gdf[self.attr] = self.gdf.index.map(novo_estado.get)\n</code></pre>"},{"location":"modules/geo/#uso-com-vizinhanca-salva-json","title":"\ud83d\udcbe Uso com vizinhan\u00e7a salva (JSON)","text":"<p>Voc\u00ea pode salvar a vizinhan\u00e7a pr\u00e9-computada para reaproveitar ou ganhar performance:</p> <pre><code>import json\n\n# Salva dicion\u00e1rio de vizinhan\u00e7a\nwith open(\"vizinhanca.json\", \"w\") as f:\n    json.dump(vizinhanca.w_.neighbors, f)\n\n# Carrega depois em outro ambiente\nviz_salva = Neighborhood(neighbors_dict=\"vizinhanca.json\")\n</code></pre>"},{"location":"modules/geo/#aplicacoes-comuns-e-integracao-com-os-modelos","title":"\ud83d\udccc Aplica\u00e7\u00f5es comuns e integra\u00e7\u00e3o com os modelos","text":"Objetivo Estrat\u00e9gia Modelos de difus\u00e3o/propaga\u00e7\u00e3o Obter estados dos vizinhos Aut\u00f4matos celulares Aplicar regras com base na vizinhan\u00e7a C\u00e1lculo de estat\u00edsticas locais (ex: LISA) Base para m\u00e9tricas espaciais locais Aglomera\u00e7\u00e3o / clusteriza\u00e7\u00e3o regional Definir contiguidade Suaviza\u00e7\u00e3o de valores espaciais M\u00e9dia/Moda entre vizinhos <p>Esse componente se encaixa perfeitamente nos modelos espaciais da biblioteca <code>DisSModel</code>, pois voc\u00ea pode:</p> <ul> <li>Incluir a vizinhan\u00e7a como parte do <code>setup</code></li> <li>Usar <code>self.neigh.idxs(idx)</code> no <code>execute</code></li> <li>Trabalhar com padr\u00f5es locais de intera\u00e7\u00e3o espacial</li> </ul> <p>Al\u00e9m de vizinhan\u00e7a topol\u00f3gica, \u00e9 poss\u00edvel construir vizinhan\u00e7a por dist\u00e2ncia com <code>KNN</code>:</p> <pre><code>from libpysal.weights import KNN\nviz_knn = Neighborhood(strategy=KNN, gdf=grade, k=4)\n\nprint(\"Vizinhos de 5-5:\", viz_knn.idxs(\"5-5\"))\n</code></pre> <p>\ud83e\udde0 \u00datil em contextos como redes de sensores, dados de pontos ou quando os pol\u00edgonos n\u00e3o se tocam. </p>"},{"location":"modules/geo/#propagacao-probabilistica","title":"\ud83d\udccc Propaga\u00e7\u00e3o Probabil\u00edstica","text":"<p>Esse modelo representa um processo de difus\u00e3o espacial com regras locais baseadas em vizinhan\u00e7a, \u00fatil para simula\u00e7\u00f5es como cont\u00e1gio, inc\u00eandios florestais, epidemias, ou dissemina\u00e7\u00e3o de inova\u00e7\u00e3o.</p> <pre><code>from dissmodel.core import Model\nimport numpy as np\n\nclass PropagacaoKNN(Model):\n    def setup(self, gdf, attr=\"estado\", k=4, prob=0.3):\n        self.gdf = gdf\n        self.attr = attr\n        self.k = k\n        self.prob = prob\n        from dissmodel.geo import Neighborhood\n        from libpysal.weights import KNN\n        self.viz = Neighborhood(strategy=KNN, gdf=gdf, k=k)\n\n    def execute(self):\n        novo_estado = self.gdf[self.attr].copy()\n        for idx in self.gdf.index:\n            if self.gdf.loc[idx, self.attr] == 1:\n                continue\n            vizinhos = self.viz.idxs(idx)\n            if any(self.gdf.loc[v, self.attr] == 1 for v in vizinhos):\n                if np.random.rand() &lt; self.prob:\n                    novo_estado.loc[idx] = 1\n        self.gdf[self.attr] = novo_estado\n</code></pre>"},{"location":"modules/visualization/","title":"Visualization","text":"<p>O m\u00f3dulo de visualiza\u00e7\u00e3o \u00e9 projetado para fornecer representa\u00e7\u00f5es interativas e atualiz\u00e1veis de modelos em execu\u00e7\u00e3o, seja atrav\u00e9s de gr\u00e1ficos temporais ou mapas geoespaciais. Ele \u00e9 composto por duas principais classes: <code>Chart</code> e <code>Map</code>, ambas herdadas de <code>Model</code>, o que permite sua integra\u00e7\u00e3o e controle direto pelo <code>Environment</code>.</p>"},{"location":"modules/visualization/#classe-chart","title":"Classe <code>Chart</code>","text":"<p>A classe <code>Chart</code> \u00e9 respons\u00e1vel por gerar gr\u00e1ficos temporais com dados provenientes da simula\u00e7\u00e3o. Os modelos podem ser anotados com o decorador <code>@track_plot</code>, que define quais vari\u00e1veis devem ser rastreadas e visualizadas. A coleta e a atualiza\u00e7\u00e3o dos dados s\u00e3o feitas automaticamente a cada execu\u00e7\u00e3o da simula\u00e7\u00e3o.</p> <p>Principais funcionalidades:</p> <ul> <li>Integra\u00e7\u00e3o direta com o <code>Environment</code>, executando a plotagem sincronizada com o tempo da simula\u00e7\u00e3o.</li> <li>Suporte \u00e0 exibi\u00e7\u00e3o local (modo interativo com <code>matplotlib</code>) e em dashboards (<code>Streamlit</code>).</li> <li>Visualiza\u00e7\u00e3o seletiva de vari\u00e1veis via argumento <code>select</code>.</li> </ul> <p>Com isso, basta adicionar <code>@track_plot</code> acima da defini\u00e7\u00e3o de uma classe para que as vari\u00e1veis sejam automaticamente monitoradas.</p>"},{"location":"modules/visualization/#classe-map","title":"Classe <code>Map</code>","text":"<p>A classe <code>Map</code> permite visualizar dinamicamente a evolu\u00e7\u00e3o espacial de dados contidos em <code>GeoDataFrames</code>. A cada passo da simula\u00e7\u00e3o, o mapa \u00e9 atualizado com base nos par\u00e2metros definidos.</p> <p>Principais funcionalidades:</p> <ul> <li>Plotagem autom\u00e1tica de dados espaciais com <code>GeoPandas</code>.</li> <li>Integra\u00e7\u00e3o direta com <code>Environment</code>.</li> <li>Suporte \u00e0 exibi\u00e7\u00e3o via <code>matplotlib</code> local ou <code>Streamlit</code>.</li> </ul>"},{"location":"modules/visualization/#decoradores-e-anotacoes","title":"Decoradores e anota\u00e7\u00f5es","text":"<p>Para especificar quais vari\u00e1veis de um modelo devem ser exibidas no gr\u00e1fico, utiliza-se o decorador <code>track_plot</code>. Esse decorador associa metadados ao modelo, que s\u00e3o lidos pela classe <code>Chart</code>.</p> <p>O m\u00e9todo <code>display_inputs</code> permite criar dinamicamente interfaces de entrada no Streamlit com base nas anota\u00e7\u00f5es de tipo do modelo:</p>"},{"location":"modules/visualization/#exemplo","title":"Exemplo","text":"<p>A seguir, mostramos como utilizar o decorador <code>@track_plot</code>, a interface de entrada via <code>Streamlit</code>, e a visualiza\u00e7\u00e3o autom\u00e1tica com <code>Chart</code>.</p>"},{"location":"modules/visualization/#definicao-do-modelo-sir","title":"Defini\u00e7\u00e3o do Modelo SIR","text":"<p>Importa\u00e7\u00f5es</p> <pre><code>from dissmodel.core import Model\nfrom dissmodel.visualization import track_plot\n</code></pre> <ul> <li>Model: Classe base de modelos no DisSModel. Todos os modelos devem herdar dessa classe.</li> <li>track_plot: Um decorador usado para indicar quais atributos devem ser monitorados e plotados ao longo do tempo. Serve para gerar automaticamente gr\u00e1ficos durante a simula\u00e7\u00e3o.</li> </ul> <p>\ud83d\udcca Decoradores @track_plot(...) <pre><code>@track_plot(\"Susceptible\", \"green\")\n@track_plot(\"Infected\", \"red\")\n@track_plot(\"Recovered\", \"blue\")\nclass SIR(Model):   \n</code></pre> Esses decoradores dizem ao DisSModel para:</p> <ul> <li> <p>Monitorar as vari\u00e1veis susceptible, infected e recovered.</p> </li> <li> <p>Associar cada uma a uma cor no gr\u00e1fico.</p> </li> </ul> <p>O resultado visual ser\u00e1 um gr\u00e1fico que mostra a evolu\u00e7\u00e3o do n\u00famero de pessoas em cada estado da epidemia ao longo do tempo.</p> <p>Tamb\u00e9m ser\u00e1 definido na classe os atributos ser\u00e3o utilizados pela func\u00e3o display_inputs.</p> <pre><code>    susceptible: int\n    infected: int\n    recovered: int\n    duration: int\n</code></pre> <p>Esses s\u00e3o atributos do modelo: - susceptible: n\u00famero de pessoas suscet\u00edveis. - infected: n\u00famero de pessoas infectadas. - recovered: n\u00famero de pessoas recuperadas. - duration: tempo m\u00e9dio que uma pessoa permanece infectada.</p> <p>O comportamento deste modelo foi descrito no modulo core. Mas a seguir tem o exemplo com os elementos que ser\u00e3o utilizados a entrada de par\u00e2metros pelo streamlit, e visualiza\u00e7\u00e3o do mapa. </p> <pre><code>from dissmodel.core import Model\nfrom dissmodel.visualization import track_plot\n\n@track_plot(\"Susceptible\", \"green\")\n@track_plot(\"Infected\", \"red\")\n@track_plot(\"Recovered\", \"blue\")\nclass SIR(Model):\n    susceptible: int\n    infected: int\n    recovered: int\n    duration: int\n\n    def __init__(self, susceptible=9998, infected=2, recovered=0, duration=2,\n                 contacts=6, probability=0.25, final_time=30):\n        super().__init__()\n        self.susceptible = susceptible\n        self.infected = infected\n        self.recovered = recovered\n        self.duration = duration\n        self.contacts = contacts\n        self.probability = probability\n        self.final_time = final_time\n\n    def update(self):\n        total = self.susceptible + self.infected + self.recovered\n        alpha = self.contacts * self.probability\n        prop = self.susceptible / total\n        new_infected = self.infected * alpha * prop\n        new_recovered = self.infected / self.duration\n        self.susceptible -= new_infected\n        self.infected += new_infected - new_recovered\n        self.recovered += new_recovered\n\n    def execute(self):\n        self.update()\n</code></pre>"},{"location":"modules/visualization/#visualizacao-com-streamlit","title":"Visualiza\u00e7\u00e3o com Streamlit","text":"<ol> <li> <p>\ud83d\udce6 Importa\u00e7\u00f5es <pre><code>import streamlit as st\nfrom dissmodel.core import Environment\nfrom dissmodel.visualization import Chart, display_inputs\nfrom models import SIR\n</code></pre></p> <ul> <li>streamlit as st: biblioteca usada para construir interfaces web interativas com Python.</li> <li>Environment: classe do DisSModel que gerencia o tempo da simula\u00e7\u00e3o.</li> <li>Chart: componente que exibe os gr\u00e1ficos com base no @track_plot usado no modelo.</li> <li>display_inputs: fun\u00e7\u00e3o que gera autom\u00e1ticamente sliders e campos no sidebar com base nos par\u00e2metros do modelo (init).</li> <li>SIR: o modelo de simula\u00e7\u00e3o definido anteriormente.</li> </ul> </li> <li> <p>\u2699\ufe0f Configura\u00e7\u00e3o da P\u00e1gina</p> <pre><code>st.set_page_config(page_title=\"SIR Model\", layout=\"centered\")\nst.title(\"SIR Model (DisSModel)\")\n</code></pre> <p>Define o t\u00edtulo da aba do navegador e o layout. Exibe o t\u00edtulo da aplica\u00e7\u00e3o na interface.</p> </li> <li> <p>\ud83c\udf9b\ufe0f Sidebar com Par\u00e2metros <pre><code>st.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\nexecutar = st.button(\"Executar Simula\u00e7\u00e3o\")\n</code></pre></p> <p>Cria um t\u00edtulo na barra lateral. Um slider que permite ao usu\u00e1rio ajustar o n\u00famero de passos da simula\u00e7\u00e3o. Um bot\u00e3o chamado \"Executar Simula\u00e7\u00e3o\", que inicia a execu\u00e7\u00e3o quando clicado.</p> </li> <li> <p>\ud83c\udf0d Cria\u00e7\u00e3o do Ambiente de Simula\u00e7\u00e3o</p> <pre><code>env = Environment(end_time=steps, start_time=0)\nCria um ambiente temporal onde o modelo ser\u00e1 executado.\n</code></pre> <p>Define o tempo inicial (start_time=0) e final (end_time=steps) com base no valor do slider.</p> </li> <li> <p>\ud83e\uddea Instancia\u00e7\u00e3o do Modelo e Inputs     <pre><code>sir = SIR()\ndisplay_inputs(sir, st.sidebar)\n</code></pre>     Cria uma inst\u00e2ncia do modelo SIR com os valores padr\u00e3o. E display_inputs(...) gera campos autom\u00e1ticos na barra lateral com os par\u00e2metros do modelo, como: contacts, probability, duration, infected, susceptible, etc.</p> <p>Isso elimina a necessidade de escrever manualmente todos os sliders.</p> </li> <li> <p>\ud83d\udcc8 Gr\u00e1fico de Acompanhamento <pre><code>Chart(plot_area=st.empty())\n</code></pre></p> <p>Cria um espa\u00e7o vazio onde o gr\u00e1fico da simula\u00e7\u00e3o ser\u00e1 exibido.</p> <p>O gr\u00e1fico mostra as vari\u00e1veis com @track_plot, ou seja: susceptible, infected e recovered.</p> </li> <li> <p>\u25b6\ufe0f Execu\u00e7\u00e3o da Simula\u00e7\u00e3o <pre><code>if executar:\n    env.reset()\n    env.run()\n</code></pre>     Quando o bot\u00e3o \"Executar Simula\u00e7\u00e3o\" for clicado:</p> <ul> <li>env.reset(): reseta o tempo e os estados internos do ambiente.</li> <li>env.run(): executa a simula\u00e7\u00e3o passo a passo, chamando o m\u00e9todo execute() do modelo a cada passo.</li> </ul> <p>O gr\u00e1fico ser\u00e1 atualizado automaticamente com os dados do @track_plot.</p> </li> </ol> <p>O codigo completo <pre><code>import streamlit as st\nfrom dissmodel.core import Environment\nfrom dissmodel.visualization import Chart, display_inputs\nfrom models import SIR\n\nst.set_page_config(page_title=\"SIR Model\", layout=\"centered\")\nst.title(\"SIR Model (DisSModel)\")\n\nst.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\nexecutar = st.button(\"Executar Simula\u00e7\u00e3o\")\n\n# Ambiente de simula\u00e7\u00e3o\nenv = Environment(end_time=steps, start_time=0)\n\n# Instancia\u00e7\u00e3o do modelo com valores padr\u00e3o\nsir = SIR()\ndisplay_inputs(sir, st.sidebar)  # Interface autom\u00e1tica\n\n# Componente gr\u00e1fico\nChart(plot_area=st.empty())\n\n# Execu\u00e7\u00e3o da simula\u00e7\u00e3o\nif executar:\n    env.reset()\n    env.run()\n</code></pre></p>"}]}