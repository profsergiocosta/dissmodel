{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DisSModel","text":"<p>Biblioteca para modelagem baseada em agentes e aut\u00f4matos celulares com suporte espacial.</p>"},{"location":"#visao-geral-da-ferramenta","title":"Vis\u00e3o Geral da Ferramenta","text":"<p>A ferramenta que aqui se apresenta foi concebida para a constru\u00e7\u00e3o e an\u00e1lise de modelos discretos, com \u00eanfase na simula\u00e7\u00e3o de sistemas din\u00e2micos espaciais. Inspirada na biblioteca Terrame, a proposta \u00e9 proporcionar um ambiente flex\u00edvel e integrado ao ecossistema Python, utilizando um conjunto de bibliotecas amplamente reconhecidas no mercado para facilitar tanto a modelagem quanto a visualiza\u00e7\u00e3o de dados espaciais.</p> <p>Embora a Terrame seja focada na simula\u00e7\u00e3o discreta e no controle de eventos discretos no dom\u00ednio territorial, a vers\u00e3o Python prop\u00f5e uma s\u00e9rie de m\u00f3dulos especializados para integrar funcionalidades geoespaciais, controle de eventos e visualiza\u00e7\u00e3o de maneira mais modular e extens\u00edvel.</p>"},{"location":"#objetivos","title":"Objetivos","text":"<ul> <li>Modelagem Discreta: A ferramenta permite a cria\u00e7\u00e3o de modelos discretos, utilizando a biblioteca Salabim para controle de eventos discretos.</li> <li>Integra\u00e7\u00e3o Espacial: Oferece uma camada robusta de suporte \u00e0 an\u00e1lise espacial por meio do uso de bibliotecas como GeoPandas, PySAL, Shapely e RasterStats, que permitem o tratamento e an\u00e1lise de dados geoespaciais.</li> <li>Visualiza\u00e7\u00e3o Interativa: Com o aux\u00edlio de Matplotlib e Streamlit, proporciona visualiza\u00e7\u00f5es ricas e interativas dos modelos gerados, auxiliando na an\u00e1lise e na interpreta\u00e7\u00e3o dos dados de maneira intuitiva.</li> <li>Publica\u00e7\u00e3o e Integra\u00e7\u00e3o: Inclui uma integra\u00e7\u00e3o com o DataWorld, permitindo que os modelos e resultados possam ser facilmente compartilhados, documentados e publicados.</li> </ul> <p>Esta ferramenta foi criada com o intuito de oferecer aos pesquisadores, analistas e engenheiros uma plataforma eficiente e adapt\u00e1vel para realizar experimentos e gerar resultados significativos em modelos discretos e an\u00e1lises espaciais.</p>"},{"location":"#estrutura-da-documentacao","title":"Estrutura da Documenta\u00e7\u00e3o","text":"<p>A documenta\u00e7\u00e3o est\u00e1 estruturada em quatro m\u00f3dulos principais, cada um com seu foco espec\u00edfico. A seguir, apresentamos os principais m\u00f3dulos que comp\u00f5em a ferramenta:</p> <ol> <li>M\u00f3dulo Core (Salabim): O m\u00f3dulo central da ferramenta, respons\u00e1vel pelo controle de eventos discretos e pela simula\u00e7\u00e3o do comportamento do modelo. Este m\u00f3dulo utiliza a biblioteca Salabim, que oferece funcionalidades robustas para a modelagem de processos discretos e controle de eventos no tempo.</li> <li>M\u00f3dulo Geo (GeoPandas, PySAL, Shapely, RasterStats): Este m\u00f3dulo oferece a infraestrutura necess\u00e1ria para trabalhar com dados geoespaciais. Com o uso de GeoPandas, \u00e9 poss\u00edvel carregar, manipular e analisar dados geogr\u00e1ficos em diversos formatos. Al\u00e9m disso, PySAL e Shapely permitem a an\u00e1lise espacial e a gera\u00e7\u00e3o de vizinhan\u00e7as, enquanto RasterStats possibilita a an\u00e1lise de dados rasterizados.</li> <li>M\u00f3dulo Visualization (Matplotlib, Streamlit): O m\u00f3dulo de visualiza\u00e7\u00e3o \u00e9 projetado para criar gr\u00e1ficos e interfaces interativas. Usando Matplotlib, \u00e9 poss\u00edvel gerar gr\u00e1ficos est\u00e1ticos detalhados, enquanto Streamlit facilita a cria\u00e7\u00e3o de interfaces interativas, permitindo ao usu\u00e1rio visualizar e manipular os resultados de maneira din\u00e2mica e em tempo real.</li> <li>M\u00f3dulo Publish (DataWorld): O m\u00f3dulo de publica\u00e7\u00e3o integra a ferramenta ao DataWorld, um ambiente colaborativo para visualiza\u00e7\u00e3o e compartilhamento de dados. Esta funcionalidade facilita a publica\u00e7\u00e3o de resultados, permitindo que o modelo e seus dados possam ser compartilhados e acessados por outros usu\u00e1rios de forma simples e eficiente.</li> </ol> <p></p>"},{"location":"examples/CA/","title":"Aut\u00f4matos Celulares no DisSModel","text":"<p>Aut\u00f4matos celulares s\u00e3o modelos baseados em grades espaciais discretas, onde cada c\u00e9lula evolui segundo regras locais que dependem do estado da pr\u00f3pria c\u00e9lula e de suas vizinhas.</p> <p>No contexto do DisSModel, utilizamos aut\u00f4matos celulares para simular processos como:</p> <ul> <li>Din\u00e2mica de popula\u00e7\u00f5es (ex. Game of Life)</li> <li>Propaga\u00e7\u00e3o de dist\u00farbios (ex. queimadas)</li> <li>Mudan\u00e7as em coberturas do solo</li> </ul> <p>A estrutura geral de um aut\u00f4mato celular no DisSModel inclui:</p> <ul> <li>Um ambiente espacial regular (grid)</li> <li>Um atributo de estado por c\u00e9lula</li> <li>Uma vizinhan\u00e7a (Rook, Queen, ou KNN via PySAL)</li> <li>Uma regra de atualiza\u00e7\u00e3o (<code>rule</code>)</li> <li>Um ciclo de execu\u00e7\u00e3o (<code>execute</code>)</li> </ul>"},{"location":"examples/CA/#estrategias-de-vizinhanca","title":"Estrat\u00e9gias de vizinhan\u00e7a","text":"<p>O DisSModel suporta diversas estrat\u00e9gias de vizinhan\u00e7a:</p> <ul> <li>Rook: considera c\u00e9lulas vizinhas nas dire\u00e7\u00f5es ortogonais (N, S, L, O)</li> <li>Queen: considera tamb\u00e9m as diagonais (N, NE, L, SE, S, SO, O, NO)</li> <li>KNN: vizinhos com base na proximidade (via <code>libpysal.weights.KNN</code>)</li> </ul> <p>Voc\u00ea pode usar qualquer uma dessas abordagens com o objeto <code>Neighborhood</code>, por exemplo:</p> <p>```python from libpysal.weights import KNN neigh = Neighborhood(KNN, gdf, use_index=True, k=4)</p>"},{"location":"examples/CA/fire_model/","title":"Modelo de Queimada","text":""},{"location":"examples/CA/fire_model/#exemplo-2-modelo-de-queimada-firemodelprob","title":"\ud83d\udd25 Exemplo 2: Modelo de Queimada (FireModelProb)","text":"<p>Este modelo simula a propaga\u00e7\u00e3o de fogo em uma floresta com regras probabil\u00edsticas:</p> <ul> <li>Uma c\u00e9lula em estado floresta pode:<ul> <li>Queimar se um vizinho estiver queimando.</li> <li>Pegar fogo com uma pequena chance aleat\u00f3ria (combust\u00e3o espont\u00e2nea).</li> </ul> </li> <li>Uma c\u00e9lula queimando vira queimada.</li> <li>Uma c\u00e9lula queimada pode voltar a ser floresta com chance de regenera\u00e7\u00e3o.</li> </ul>"},{"location":"examples/CA/fire_model/#estados","title":"Estados","text":"<pre><code>FOREST = 0      # Verde\nBURNING = 1     # Vermelho\nBURNED = 2      # Marrom\n</code></pre>"},{"location":"examples/CA/fire_model/#regra-de-transicao","title":"Regra de transi\u00e7\u00e3o","text":"<pre><code>def rule(self, idx):\n    state = self.gdf.loc[idx].state\n    if state == FOREST:\n        neighs = self.neighborhood.neighs(idx)\n        if (neighs.state == BURNING).any():\n            return BURNING\n        return BURNING if random.random() &lt; self.prob_combustion else FOREST\n    elif state == BURNING:\n        return BURNED\n    else:\n        return FOREST if random.random() &lt; self.prob_regrowth else BURNED\n</code></pre>"},{"location":"examples/CA/fire_model/#variacao-estrategias-de-vizinhanca","title":"Varia\u00e7\u00e3o: Estrat\u00e9gias de Vizinhan\u00e7a","text":"<p>Voc\u00ea pode trocar o tipo de vizinhan\u00e7a com um \u00fanico par\u00e2metro:</p> <pre><code>self.neighborhood = Neighborhood(Rook, gdf, use_index=True)\n</code></pre> <p>Ou usar KNN (K-Nearest Neighbors):</p> <pre><code>from libpysal.weights import KNN\nneigh = Neighborhood(KNN, gdf, k=4, use_index=True)\n</code></pre>"},{"location":"examples/CA/fire_model/#exemplo-de-execucao","title":"\ud83d\udcf7 Exemplo de execu\u00e7\u00e3o","text":""},{"location":"examples/CA/fire_model/#codigo-completo-firemodelprob","title":"\ud83d\udcbb C\u00f3digo completo (FireModelProb)","text":"<pre><code>from dissmodel.core import Model, Environment\nfrom dissmodel.geo.regular_grid import regular_grid\nfrom dissmodel.geo.fill import fill\nfrom dissmodel.visualization import Map\nfrom dissmodel.visualization.streamlit import display_inputs\nfrom matplotlib.colors import ListedColormap\nimport streamlit as st\nimport random\nfrom dissmodel.geo.neihborhood import Neighborhood\nfrom libpysal.weights.contiguity import Queen\n\nclass FireModelProb(Model):\n    FOREST = 0\n    BURNING = 1\n    BURNED = 2\n\n    def __init__(self, gdf, prob_combustion=0.001, prob_regrowth=0.1, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.prob_combustion = prob_combustion\n        self.prob_regrowth = prob_regrowth\n        self.gdf = gdf\n        self.neighborhood = Neighborhood(Queen, gdf, use_index=True)\n\n    def rule(self, idx):\n        state = self.gdf.loc[idx].state\n        if state == FireModelProb.FOREST:\n            neighs = self.neighborhood.neighs(idx)\n            if (neighs.state == FireModelProb.BURNING).any():\n                return FireModelProb.BURNING\n            else:\n                return FireModelProb.BURNING if random.random() &lt;= self.prob_combustion else FireModelProb.FOREST\n        elif state == FireModelProb.BURNING:\n            return FireModelProb.BURNED\n        else:\n            return FireModelProb.FOREST if random.random() &lt;= self.prob_regrowth else FireModelProb.BURNED\n\n    def execute(self):\n        self.gdf[\"state\"] = self.gdf.index.map(self.rule)\n\nst.set_page_config(page_title=\"Fire Model\", layout=\"centered\")\nst.title(\"Fire Model (DisSModel)\")\n\nst.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\ngrid_dim = st.sidebar.slider(\"Tamanho da grade\", min_value=5, max_value=100, value=20)\nexecutar = st.button(\"Executar Simula\u00e7\u00e3o\")\n\ngdf = regular_grid(dimension=(grid_dim, grid_dim), resolution=1, attrs={'state': 0})\nenv = Environment(end_time=steps, start_time=0)\nfire = FireModelProb(gdf=gdf)\ndisplay_inputs(fire, st.sidebar)\n\nplot_area = st.empty()\ncustom_cmap = ListedColormap(['green', 'red', 'brown'])\nplot_params = {\"column\": \"state\", \"cmap\": custom_cmap, \"ec\": \"black\"}\n\nMap(gdf=gdf, plot_area=plot_area, plot_params=plot_params)\n\nif executar:\n    env.run()\n</code></pre>"},{"location":"examples/CA/game_of_life/","title":"Game of Life","text":""},{"location":"examples/CA/game_of_life/#exemplo-1-game-of-life-jogo-da-vida","title":"\ud83d\udd32 Exemplo 1: Game of Life (Jogo da Vida)","text":"<p>O Game of Life, criado por John Conway, \u00e9 um aut\u00f4mato celular cl\u00e1ssico com regras simples:</p> <ul> <li>Uma c\u00e9lula viva permanece viva com 2 ou 3 vizinhos vivos.</li> <li>Uma c\u00e9lula morta revive com exatamente 3 vizinhos vivos.</li> </ul>"},{"location":"examples/CA/game_of_life/#componentes-do-modelo","title":"\ud83e\udde9 Componentes do Modelo","text":"<ul> <li>A grade \u00e9 inicializada com padr\u00f5es (ex: <code>glider</code>, <code>toad</code>, etc.), usando <code>fill(..., strategy=FillStrategy.PATTERN)</code>.</li> <li>A vizinhan\u00e7a usada \u00e9 a Queen, que considera os 8 vizinhos ao redor.</li> <li>A regra de atualiza\u00e7\u00e3o verifica o n\u00famero de vizinhos vivos para decidir o pr\u00f3ximo estado.</li> </ul> <pre><code>class GameOfLife(Model):\n    def rule(self, idx):\n        value = self.gdf.loc[idx].state\n        count = self.neighborhood.neighs(idx)[\"state\"].fillna(0).sum()\n        if value == 1:\n            return 1 if count in [2, 3] else 0\n        else:\n            return 1 if count == 3 else 0\n</code></pre>"},{"location":"examples/CA/game_of_life/#visualizacao","title":"\ud83d\uddbc\ufe0f Visualiza\u00e7\u00e3o","text":"<p>A visualiza\u00e7\u00e3o utiliza <code>Map(...)</code> com colormap personalizado:</p> <ul> <li>C\u00e9lulas vivas em vermelho (<code>state = 1</code>)</li> <li>C\u00e9lulas mortas em verde (<code>state = 0</code>)</li> <li>Interface interativa com <code>Streamlit</code> para ajustar tamanho da grade e passos da simula\u00e7\u00e3o.</li> </ul>"},{"location":"examples/CA/game_of_life/#exemplo-de-execucao","title":"\ud83d\udcf7 Exemplo de execu\u00e7\u00e3o","text":""},{"location":"examples/CA/game_of_life/#codigo-completo-game-of-life","title":"\ud83d\udcbb C\u00f3digo completo (Game of Life)","text":"<pre><code>from dissmodel.core import Model, Environment\nfrom dissmodel.geo import regular_grid, fill, FillStrategy, Neighborhood\nfrom dissmodel.visualization.map import Map\nfrom matplotlib.colors import ListedColormap\nimport streamlit as st\nimport random\nfrom libpysal.weights.contiguity import Queen\n\nclass GameOfLife(Model):\n    patterns = {\n        \"glider\": [\n            [0, 1, 0],\n            [0, 0, 1],\n            [1, 1, 1]\n        ],\n        \"toad\": [\n            [0, 1, 1, 1],\n            [1, 1, 1, 0]\n        ],\n        \"blinker\": [\n            [1, 1, 1]\n        ]\n    }\n\n    def setup(self, gdf):\n        self.gdf = gdf\n        self.neighborhood = Neighborhood(Queen, gdf, use_index=True)   \n\n    def rule(self, idx):\n        value = self.gdf.loc[idx].state\n        neighs = self.neighborhood.neighs(idx)\n        count = neighs[\"state\"].fillna(0).sum()\n        if value == 1:\n            return 1 if count in [2, 3] else 0\n        else:\n            return 1 if count == 3 else 0\n\n    def execute(self):\n        self.gdf[\"state\"] = self.gdf.index.map(self.rule)\n        print(self.env.now())\n\nst.set_page_config(page_title=\"Modelo Game of Life\", layout=\"centered\")\nst.title(\"Simula\u00e7\u00e3o com Game of Life (DisSModel)\")\n\nst.sidebar.title(\"Par\u00e2metros do Modelo\")\nsteps = st.sidebar.slider(\"N\u00famero de passos da simula\u00e7\u00e3o\", min_value=1, max_value=50, value=10)\ngrid_dim = st.sidebar.slider(\"Tamanho da grade\", min_value=5, max_value=50, value=20)\n\ncustom_cmap = ListedColormap(['green', 'red'])\nplot_params = { \"column\": \"state\", \"cmap\": custom_cmap, \"ec\": 'black' }\n\ngrid = regular_grid(dimension=(grid_dim, grid_dim), resolution=1, attrs={'state': 0})\n\nfor name, pattern in GameOfLife.patterns.items():\n    start_x = random.randint(0, grid_dim - 5)\n    start_y = random.randint(0, grid_dim - 5)\n    fill(strategy=FillStrategy.PATTERN, gdf=grid, attr=\"state\", pattern=pattern, start_x=start_x, start_y=start_y)\n\nenv = Environment(end_time=steps, start_time=0)\nGameOfLife(gdf=grid)\n\nif st.button(\"Executar Simula\u00e7\u00e3o\"):\n    plot_area = st.empty()\n    Map(gdf=grid, plot_area=plot_area, plot_params=plot_params)\n    env.run()\n</code></pre>"}]}